{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/22971",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/22971/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/22971/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/22971/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/22971",
  "id": 1106932935,
  "node_id": "I_kwDOCFbutM5B-nTH",
  "number": 22971,
  "title": "Authentication: cannot map `AuthenticationFailedException`",
  "labels": [
    {
      "id": 985346620,
      "node_id": "MDU6TGFiZWw5ODUzNDY2MjA=",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/kind/bug",
      "name": "kind/bug",
      "color": "d73a4a",
      "default": false,
      "description": "Something isn't working"
    },
    {
      "id": 1282139374,
      "node_id": "MDU6TGFiZWwxMjgyMTM5Mzc0",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/security",
      "name": "area/security",
      "color": "0366d6",
      "default": false,
      "description": ""
    },
    {
      "id": 1479557456,
      "node_id": "MDU6TGFiZWwxNDc5NTU3NDU2",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/oidc",
      "name": "area/oidc",
      "color": "0366d6",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "milestone": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/milestones/206",
    "html_url": "https://github.com/quarkusio/quarkus/milestone/206",
    "labels_url": "https://api.github.com/repos/quarkusio/quarkus/milestones/206/labels",
    "id": 8420367,
    "node_id": "MI_kwDOCFbutM4AgHwP",
    "number": 206,
    "title": "2.14.0.CR1",
    "description": "",
    "creator": {
      "login": "gsmet",
      "id": 1279749,
      "node_id": "MDQ6VXNlcjEyNzk3NDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1279749?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gsmet",
      "html_url": "https://github.com/gsmet",
      "followers_url": "https://api.github.com/users/gsmet/followers",
      "following_url": "https://api.github.com/users/gsmet/following{/other_user}",
      "gists_url": "https://api.github.com/users/gsmet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gsmet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gsmet/subscriptions",
      "organizations_url": "https://api.github.com/users/gsmet/orgs",
      "repos_url": "https://api.github.com/users/gsmet/repos",
      "events_url": "https://api.github.com/users/gsmet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gsmet/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 0,
    "closed_issues": 224,
    "state": "closed",
    "created_at": "2022-09-14T06:18:10Z",
    "updated_at": "2023-05-15T13:54:56Z",
    "due_on": null,
    "closed_at": "2022-10-26T12:52:36Z"
  },
  "comments": 7,
  "created_at": "2022-01-18T13:50:20Z",
  "updated_at": "2022-10-14T11:37:40Z",
  "closed_at": "2022-10-14T11:37:37Z",
  "active_lock_reason": null,
  "body": "### Describe the bug\n\n`HttpSecurityRecorder` uses this exception mapper:\r\n\r\n```java\r\n                //register the default auth failure handler\r\n                //if proactive auth is used this is the only one\r\n                //if using lazy auth this can be modified downstream, to control authentication behaviour\r\n                event.put(QuarkusHttpUser.AUTH_FAILURE_HANDLER, new BiConsumer<RoutingContext, Throwable>() {\r\n                    @Override\r\n                    public void accept(RoutingContext routingContext, Throwable throwable) {\r\n                        throwable = extractRootCause(throwable);\r\n                        //auth failed\r\n                        if (throwable instanceof AuthenticationFailedException) {\r\n                            authenticator.sendChallenge(event).subscribe().with(new Consumer<Boolean>() {\r\n                                @Override\r\n                                public void accept(Boolean aBoolean) {\r\n                                    if (!event.response().ended()) {\r\n                                        event.response().end();\r\n                                    }\r\n                                }\r\n                            }, new Consumer<Throwable>() {\r\n                                @Override\r\n                                public void accept(Throwable throwable) {\r\n                                    event.fail(throwable);\r\n                                }\r\n                            });\r\n                        } else if (throwable instanceof AuthenticationCompletionException) {\r\n                            event.response().setStatusCode(401);\r\n                            event.response().end();\r\n                        } else if (throwable instanceof AuthenticationRedirectException) {\r\n                            AuthenticationRedirectException redirectEx = (AuthenticationRedirectException) throwable;\r\n                            event.response().setStatusCode(redirectEx.getCode());\r\n                            event.response().headers().set(HttpHeaders.LOCATION, redirectEx.getRedirectUri());\r\n                            event.response().headers().set(HttpHeaders.CACHE_CONTROL, \"no-store\");\r\n                            event.response().headers().set(\"Pragma\", \"no-cache\");\r\n                            event.response().end();\r\n                        } else {\r\n                            event.fail(throwable);\r\n                        }\r\n                    }\r\n```\r\n\r\nWhich means that some exceptions are handled directly, and can't be mapped by RESTEasy Reactive, even though when using non-proactive authentication, RR still comes later into play and will try to map the exception and write it out and will cause an ignored exception because the response has already been written.\r\n\r\nNote that `authenticator.sendChallenge(event)` also sets the response in `HttpAuthenticator`:\r\n\r\n```java\r\n    public Uni<Boolean> sendChallenge(RoutingContext routingContext) {\r\n        //we want to consume any body content if present\r\n        //challenges won't read the body, and if we don't consume\r\n        //things can get stuck\r\n        routingContext.request().resume();\r\n        Uni<Boolean> result = null;\r\n\r\n        HttpAuthenticationMechanism matchingMech = routingContext.get(HttpAuthenticationMechanism.class.getName());\r\n        if (matchingMech != null) {\r\n            result = matchingMech.sendChallenge(routingContext);\r\n        }\r\n        if (result == null) {\r\n            result = mechanisms[0].sendChallenge(routingContext);\r\n            for (int i = 1; i < mechanisms.length; ++i) {\r\n                HttpAuthenticationMechanism mech = mechanisms[i];\r\n                result = result.onItem().transformToUni(new Function<Boolean, Uni<? extends Boolean>>() {\r\n                    @Override\r\n                    public Uni<? extends Boolean> apply(Boolean authDone) {\r\n                        if (authDone) {\r\n                            return Uni.createFrom().item(authDone);\r\n                        }\r\n                        return mech.sendChallenge(routingContext);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return result.onItem().transformToUni(new Function<Boolean, Uni<? extends Boolean>>() {\r\n            @Override\r\n            public Uni<? extends Boolean> apply(Boolean authDone) {\r\n                if (!authDone) {\r\n                    routingContext.response().setStatusCode(401);\r\n                    routingContext.response().end();\r\n                }\r\n                return Uni.createFrom().item(authDone);\r\n            }\r\n        });\r\n    }\r\n```\n\n### Expected behavior\n\nI want to be able to map the exceptions to what I want, without having to register a Vert.x route just to be able to override the `QuarkusHttpUser.AUTH_FAILURE_HANDLER`, and I'd prefer if it were mapped by RESTEasy Reactive using the existing exception mapping process.\r\n\r\nCC @stuartwdouglas @sberyozkin @geoand \n\n### Actual behavior\n\n_No response_\n\n### How to Reproduce?\n\n_No response_\n\n### Output of `uname -a` or `ver`\n\n_No response_\n\n### Output of `java -version`\n\n_No response_\n\n### GraalVM version (if different from Java)\n\n_No response_\n\n### Quarkus version or git rev\n\n_No response_\n\n### Build tool (ie. output of `mvnw --version` or `gradlew --version`)\n\n_No response_\n\n### Additional information\n\n_No response_",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/22971/reactions",
    "total_count": 2,
    "+1": 2,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/22971/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
