{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/35925",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/35925/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/35925/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/35925/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/35925",
  "id": 1895787922,
  "node_id": "I_kwDOCFbutM5w_22S",
  "number": 35925,
  "title": "Add a property to bypass cache mechanism in case of Redis failure",
  "labels": [
    {
      "id": 985346622,
      "node_id": "MDU6TGFiZWw5ODUzNDY2MjI=",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/kind/enhancement",
      "name": "kind/enhancement",
      "color": "a2eeef",
      "default": false,
      "description": "New feature or request"
    },
    {
      "id": 1808747697,
      "node_id": "MDU6TGFiZWwxODA4NzQ3Njk3",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/cache",
      "name": "area/cache",
      "color": "0366d6",
      "default": false,
      "description": ""
    },
    {
      "id": 2184343143,
      "node_id": "MDU6TGFiZWwyMTg0MzQzMTQz",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/redis",
      "name": "area/redis",
      "color": "0366d6",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "milestone": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/milestones/277",
    "html_url": "https://github.com/quarkusio/quarkus/milestone/277",
    "labels_url": "https://api.github.com/repos/quarkusio/quarkus/milestones/277/labels",
    "id": 9938825,
    "node_id": "MI_kwDOCFbutM4Al6eJ",
    "number": 277,
    "title": "3.4.1",
    "description": "",
    "creator": {
      "login": "gsmet",
      "id": 1279749,
      "node_id": "MDQ6VXNlcjEyNzk3NDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1279749?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gsmet",
      "html_url": "https://github.com/gsmet",
      "followers_url": "https://api.github.com/users/gsmet/followers",
      "following_url": "https://api.github.com/users/gsmet/following{/other_user}",
      "gists_url": "https://api.github.com/users/gsmet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gsmet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gsmet/subscriptions",
      "organizations_url": "https://api.github.com/users/gsmet/orgs",
      "repos_url": "https://api.github.com/users/gsmet/repos",
      "events_url": "https://api.github.com/users/gsmet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gsmet/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 0,
    "closed_issues": 21,
    "state": "closed",
    "created_at": "2023-09-19T15:38:46Z",
    "updated_at": "2023-10-31T17:03:57Z",
    "due_on": null,
    "closed_at": "2023-09-20T14:13:10Z"
  },
  "comments": 2,
  "created_at": "2023-09-14T06:14:03Z",
  "updated_at": "2023-09-19T15:42:17Z",
  "closed_at": "2023-09-18T08:14:32Z",
  "active_lock_reason": null,
  "body": "### Description\n\nWith the current implementation of Redis cache, when Redis is not available, cache mechanism fail and there is no easy way to handle the failure and perform the call. An implementation example:\r\n```java\r\n@Fallback(fallbackMethod = \"getBooksByAuthorImpl\")\r\n@Transactional\r\npublic Books getBooksByAuthor(String author) {\r\n    return getBooksByAuthorInternal(author);\r\n}\r\n\r\n@CacheResult(cacheName = \"books\")\r\nBooks getBooksByAuthorInternal(String author) {\r\n    return getBooksByAuthorImpl(author);\r\n}\r\n\r\nBooks getBooksByAuthorImpl(String author) {\r\n    Log.info(\"Get books from \" + author);\r\n     return new Books(mapper.fromEntities(bookService.getBooksByAuthor(author)));\r\n}\r\n```\n\n### Implementation ideas\n\nThe idea could be to add a property, for example `quarkus.cache.redis.enble-failover`, to handle exceptions coming from the connection to Redis, and continue the execution as the value is not yet in cache.\r\n\r\nIn my use case, Redis is in a standalone mode, so I suggest this property could have effect only if the client is setup in standalone mode.",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/35925/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/35925/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
