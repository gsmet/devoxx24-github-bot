{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/42337",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/42337/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/42337/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/42337/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/42337",
  "id": 2450574314,
  "node_id": "I_kwDOCFbutM6SEMvq",
  "number": 42337,
  "title": "StackOverflowError when firing event in @PreDestroy listener",
  "labels": [
    {
      "id": 985346620,
      "node_id": "MDU6TGFiZWw5ODUzNDY2MjA=",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/kind/bug",
      "name": "kind/bug",
      "color": "d73a4a",
      "default": false,
      "description": "Something isn't working"
    },
    {
      "id": 1282102389,
      "node_id": "MDU6TGFiZWwxMjgyMTAyMzg5",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/arc",
      "name": "area/arc",
      "color": "0366d6",
      "default": false,
      "description": "Issue related to ARC (dependency injection)"
    }
  ],
  "state": "closed",
  "locked": false,
  "milestone": null,
  "comments": 11,
  "created_at": "2024-08-06T10:51:03Z",
  "updated_at": "2024-08-29T09:47:37Z",
  "closed_at": "2024-08-29T09:47:37Z",
  "active_lock_reason": null,
  "body": "### Describe the bug\r\n\r\nWe currently try to switch from 3.2.9.Final to 3.8.5. Here we run into the problem, that we get an `StackOverflowError` during the destroy phase of a `RequestScoped` bean. Here we fire an event in a method which is annotated with `@PreDestroy`. This seems to create a new context, which leads to the creation of a new instance of our request scoped bean.\r\n\r\nThe reason for the loop/StackOverflowError seems to be a change in the method `io.quarkus.arc.impl.RequestContext#isActive()`, because in version 3.8.5 a check for the request context state is done, which was not the case in 3.2.9.Final. \r\n\r\n**3.8.5**\r\n```\r\n@Override\r\npublic boolean isActive() {\r\n    return isActive(currentContext.get());\r\n}\r\n\r\nprivate boolean isActive(RequestContextState state) {\r\n    return state == null ? false : state.isValid();\r\n}\r\n```\r\n\r\n**3.2.9.Final**\r\n```\r\n@Override\r\npublic boolean isActive() {\r\n    return currentContext.get() != null;\r\n}\r\n```\r\n\r\nThis method is used in `io.quarkus.arc.impl.EventImpl.Notifier#notify(T, io.quarkus.arc.impl.EventImpl.ObserverExceptionHandler, boolean)`. If the request context is not \"active\" (marked as invalid), it \"activates\" the request context, notifies the observers and terminates the request context afterwards.\r\n\r\n```\r\nvoid notify(T event, EventImpl.ObserverExceptionHandler exceptionHandler, boolean async) {\r\n    if (!isEmpty()) {\r\n        //[...]\r\n\r\n        // Non-tx observers notifications\r\n        // req. context is activated if not in strict mode and not for lifecycle events such as init/shutdown\r\n        if (activateRequestContext) {\r\n            ManagedContext requestContext = Arc.container().requestContext();\r\n            if (requestContext.isActive()) {\r\n                notifyObservers(event, exceptionHandler, predicate);\r\n            } else {\r\n                try {\r\n                    requestContext.activate();\r\n                    notifyObservers(event, exceptionHandler, predicate);\r\n                } finally {\r\n                    requestContext.terminate();\r\n                }\r\n            }\r\n        } else {\r\n            notifyObservers(event, exceptionHandler, predicate);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis activation leads to the creation of the request scoped bean (same as where we fire the event) and also to the termination/destroy of the bean. This again leads to the creation, etc.\r\n\r\nAs mentioned, we didn't had this problem, as in 3.2.9.Final, a request context was active when the current context was not null. Now it additionally checks the state, which is set, before the `PreDestroy` observers are called.\r\n\r\n**io.quarkus.arc.impl.RequestContext#destroy(io.quarkus.arc.InjectableContext.ContextState)**\r\n```\r\nif (reqState.invalidate()) { // state is set to invalid\r\n    // Fire an event with qualifier @BeforeDestroyed(RequestScoped.class) if there are any observers for it\r\n    fireIfNotEmpty(beforeDestroyedNotifier);\r\n\r\n    // [...]\r\n}\r\n```\r\n\r\nHere I don't know whether this is useful as I would expect that my beans/contexts are still valid, as we are in the **Pre**Destroy phase.\r\n\r\nMaybe the problem is a different, but this is what I saw.\r\n\r\n### Expected behavior\r\n\r\nI would expect that it works as before (with Quarkus 3.2.9.Final) - no new beans/contexts should be created during destroy of my request scoped bean. I think the current context should not be invalidated before the observers/listeners are called. But in the end the solution might be different.\r\n\r\n### Actual behavior\r\n\r\nEverytime the request scoped bean is destoyed, a new one is created, which then gets destoyed, which creates a new one, etc. So we end up in an stack overflow.\r\n\r\nWhen I log the stacktrace in a `PostConstruct` listener, we can see the behavior:\r\n\r\n```\r\n2024-08-06 12:29:22,475 INFO  [org.acm.imp.RequestContextIdImpl] (main) postConstruct stacktrace [a939c69e-d0f1-4a7a-9062-89534ba85d45] \r\n        java.base/java.lang.Thread.getStackTrace(Thread.java:2450)\r\n        org.acme.impl.RequestContextIdImpl.postConstruct(RequestContextIdImpl.java:25)\r\n        org.acme.impl.RequestContextIdImpl_Bean.doCreate(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.create(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.create(Unknown Source)\r\n        io.quarkus.arc.impl.RequestContext$1.get(RequestContext.java:79)\r\n        io.quarkus.arc.impl.RequestContext$1.get(RequestContext.java:75)\r\n        io.quarkus.arc.generator.Default_jakarta_enterprise_context_RequestScoped_ContextInstances.c0(Unknown Source)\r\n        io.quarkus.arc.generator.Default_jakarta_enterprise_context_RequestScoped_ContextInstances.computeIfAbsent(Unknown Source)\r\n        io.quarkus.arc.impl.RequestContext.getIfActive(RequestContext.java:75)\r\n        io.quarkus.arc.impl.ClientProxies.getSingleContextDelegate(ClientProxies.java:28)\r\n        org.acme.impl.RequestContextIdImpl_ClientProxy.arc$delegate(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_ClientProxy.getId(Unknown Source)\r\n        org.acme.impl.ScopeControlImpl.requestBegin(ScopeControlImpl.java:42)\r\n        org.acme.impl.ScopeControlImpl_Observer_requestBegin_mw2VP99394RKqVtjuIvXp784XXI.notify(Unknown Source)\r\n        io.quarkus.arc.impl.EventImpl$Notifier.notifyObservers(EventImpl.java:346)\r\n        io.quarkus.arc.impl.EventImpl$Notifier.notify(EventImpl.java:334)\r\n        io.quarkus.arc.impl.EventImpl$Notifier.notify(EventImpl.java:263)\r\n        io.quarkus.arc.impl.RequestContext.fireIfNotEmpty(RequestContext.java:238)\r\n        io.quarkus.arc.impl.RequestContext.activate(RequestContext.java:145)\r\n        io.quarkus.arc.ManagedContext.activate(ManagedContext.java:17)\r\n        io.quarkus.arc.impl.EventImpl$Notifier.notify(EventImpl.java:327)\r\n        io.quarkus.arc.impl.EventImpl.fire(EventImpl.java:82)\r\n        org.acme.impl.ScopeControlImpl.fireRequestEnd(ScopeControlImpl.java:34)\r\n        org.acme.impl.ScopeControlImpl_ClientProxy.fireRequestEnd(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl.preDestroy(RequestContextIdImpl.java:39)\r\n        org.acme.impl.RequestContextIdImpl_Bean.doDestroy(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.destroy(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.destroy(Unknown Source)\r\n        io.quarkus.arc.impl.AbstractInstanceHandle.destroyInternal(AbstractInstanceHandle.java:78)\r\n        io.quarkus.arc.impl.ContextInstanceHandleImpl.destroy(ContextInstanceHandleImpl.java:26)\r\n        io.quarkus.arc.generator.Default_jakarta_enterprise_context_RequestScoped_ContextInstances.removeEach(Unknown Source)\r\n        io.quarkus.arc.impl.RequestContext.destroy(RequestContext.java:217)\r\n        io.quarkus.arc.impl.RequestContext.destroy(RequestContext.java:200)\r\n        io.quarkus.arc.ManagedContext.terminate(ManagedContext.java:50)\r\n        io.quarkus.arc.impl.EventImpl$Notifier.notify(EventImpl.java:330)\r\n        io.quarkus.arc.impl.EventImpl.fire(EventImpl.java:82)\r\n        org.acme.impl.ScopeControlImpl.fireRequestEnd(ScopeControlImpl.java:34)\r\n        org.acme.impl.ScopeControlImpl_ClientProxy.fireRequestEnd(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl.preDestroy(RequestContextIdImpl.java:39)\r\n        org.acme.impl.RequestContextIdImpl_Bean.doDestroy(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.destroy(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.destroy(Unknown Source)\r\n        io.quarkus.arc.impl.AbstractInstanceHandle.destroyInternal(AbstractInstanceHandle.java:78)\r\n        io.quarkus.arc.impl.ContextInstanceHandleImpl.destroy(ContextInstanceHandleImpl.java:26)\r\n        io.quarkus.arc.generator.Default_jakarta_enterprise_context_RequestScoped_ContextInstances.removeEach(Unknown Source)\r\n        io.quarkus.arc.impl.RequestContext.destroy(RequestContext.java:217)\r\n        io.quarkus.arc.impl.RequestContext.destroy(RequestContext.java:200)\r\n        io.quarkus.arc.ManagedContext.terminate(ManagedContext.java:50)\r\n        io.quarkus.arc.impl.EventImpl$Notifier.notify(EventImpl.java:330)\r\n        io.quarkus.arc.impl.EventImpl.fire(EventImpl.java:82)\r\n        org.acme.impl.ScopeControlImpl.fireRequestEnd(ScopeControlImpl.java:34)\r\n        org.acme.impl.ScopeControlImpl_ClientProxy.fireRequestEnd(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl.preDestroy(RequestContextIdImpl.java:39)\r\n        org.acme.impl.RequestContextIdImpl_Bean.doDestroy(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.destroy(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.destroy(Unknown Source)\r\n        io.quarkus.arc.impl.AbstractInstanceHandle.destroyInternal(AbstractInstanceHandle.java:78)\r\n        io.quarkus.arc.impl.ContextInstanceHandleImpl.destroy(ContextInstanceHandleImpl.java:26)\r\n        io.quarkus.arc.generator.Default_jakarta_enterprise_context_RequestScoped_ContextInstances.removeEach(Unknown Source)\r\n        io.quarkus.arc.impl.RequestContext.destroy(RequestContext.java:217)\r\n        io.quarkus.arc.impl.RequestContext.destroy(RequestContext.java:200)\r\n        io.quarkus.arc.ManagedContext.terminate(ManagedContext.java:50)\r\n        io.quarkus.arc.impl.EventImpl$Notifier.notify(EventImpl.java:330)\r\n        io.quarkus.arc.impl.EventImpl.fire(EventImpl.java:82)\r\n        org.acme.impl.ScopeControlImpl.fireRequestEnd(ScopeControlImpl.java:34)\r\n        org.acme.impl.ScopeControlImpl_ClientProxy.fireRequestEnd(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl.preDestroy(RequestContextIdImpl.java:39)\r\n        org.acme.impl.RequestContextIdImpl_Bean.doDestroy(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.destroy(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.destroy(Unknown Source)\r\n        io.quarkus.arc.impl.AbstractInstanceHandle.destroyInternal(AbstractInstanceHandle.java:78)\r\n        io.quarkus.arc.impl.ContextInstanceHandleImpl.destroy(ContextInstanceHandleImpl.java:26)\r\n        io.quarkus.arc.generator.Default_jakarta_enterprise_context_RequestScoped_ContextInstances.removeEach(Unknown Source)\r\n        io.quarkus.arc.impl.RequestContext.destroy(RequestContext.java:217)\r\n        io.quarkus.arc.impl.RequestContext.destroy(RequestContext.java:200)\r\n        io.quarkus.arc.ManagedContext.terminate(ManagedContext.java:50)\r\n        io.quarkus.arc.impl.EventImpl$Notifier.notify(EventImpl.java:330)\r\n        io.quarkus.arc.impl.EventImpl.fire(EventImpl.java:82)\r\n        org.acme.impl.ScopeControlImpl.fireRequestEnd(ScopeControlImpl.java:34)\r\n        org.acme.impl.ScopeControlImpl_ClientProxy.fireRequestEnd(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl.preDestroy(RequestContextIdImpl.java:39)\r\n        org.acme.impl.RequestContextIdImpl_Bean.doDestroy(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.destroy(Unknown Source)\r\n        org.acme.impl.RequestContextIdImpl_Bean.destroy(Unknown Source)\r\n[...]\r\n```\r\n\r\nDuring the Maven build (with tests), we often run into a StackOverflowError (adjusted log of our real application):\r\n\r\n```\r\n2024-08-01 09:17:52,079 ERROR [io.qua.arc.imp.UncaughtExceptions] (main) Error occurred while destroying instance of CLASS bean [types=[org.acme.impl.AbstractContextId, java.io.Serializable, org.acme.impl.RequestContextIdImpl, org.acme.ContextId, java.lang.Object], qualifiers=[@Any, @RequestId], target=org.acme.impl.RequestContextIdImpl]: java.lang.StackOverflowError [Error Occurred After Shutdown]\r\n2024-08-01 09:17:52,259 INFO  [io.quarkus] (main) context-loop-test stopped in 0.219s\r\n@QuarkusTest has detected a hang, as there has been no test activity in PT10M\r\nTo configure this timeout use the quarkus.test.hang-detection-timeout config property\r\nA stack trace is below to help diagnose the potential hang\r\n=== Stack Trace ===\r\n...\r\n```\r\n\r\n### How to Reproduce?\r\n\r\nReproducer: https://github.com/timonzi/quarkus-3.8-bean-loop\r\n\r\nExecute `mvn clean install`\r\n\r\nHints: \r\n* When executing the tests via the IDE (in my case IntelliJ), the test finishes after some seconds - but at the end the problem is the same.\r\n* When executing the tests via Maven, we often (not always) get the StackOverflowError (in our real application)\r\n* The log output is pretty long as I log the  stacktrace everytime we run into the `PostConstruct` listener.\r\n\r\n### Output of `uname -a` or `ver`\r\n\r\nLinux timon-laptop 6.9.10-1-MANJARO #1 SMP PREEMPT_DYNAMIC Fri Jul 19 15:08:51 UTC 2024 x86_64 GNU/Linux\r\n\r\n### Output of `java -version`\r\n\r\nopenjdk version \"17.0.12\" 2024-07-16\r\n\r\n### Quarkus version or git rev\r\n\r\n3.8.5\r\n\r\n### Build tool (ie. output of `mvnw --version` or `gradlew --version`)\r\n\r\nApache Maven 3.9.8 (36645f6c9b5079805ea5009217e36f2cffd34256)\r\n\r\n### Additional information\r\n\r\nI tested with multiple Maven and OpenJDK versions.\r\n\r\nAnd sorry for adding so much code and logs.",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/42337/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/42337/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
