{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/30598",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/30598/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/30598/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/30598/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/30598",
  "id": 1556447955,
  "node_id": "I_kwDOCFbutM5cxYLT",
  "number": 30598,
  "title": "Weird results for virtual threads load test experiment + netty-loom-adaptor configuration",
  "labels": [
    {
      "id": 2552031458,
      "node_id": "MDU6TGFiZWwyNTUyMDMxNDU4",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/rest",
      "name": "area/rest",
      "color": "0366d6",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "milestone": null,
  "comments": 8,
  "created_at": "2023-01-25T10:58:50Z",
  "updated_at": "2024-01-07T09:42:40Z",
  "closed_at": "2024-01-07T09:42:40Z",
  "active_lock_reason": null,
  "body": "Hello everyone,\r\n\r\nI've been experimenting with Quarkus' virtual thread integration and ran some benchmarks. I got some results which I can't make sense of which is why I'm asking for advice here.\r\n\r\nI used wrk2 to fire requests to three endpoints running respectively on the event loop, a worker thread and a virtual thread with `@RunOnVirtual Thread`. The endpoints send a query to a Postgres DB and returns the result as JSON with Jackson similar to what @anavarr did [here](https://github.com/anavarr/quarkus-fortunes-all-endpoints) and [here](https://github.com/anavarr/fortunes_benchmark).\r\nThe reactive event loop version uses the reactive Postgres client and so does the virtual thread version to avoid pinning carrier threads. The blocking version uses direct JDBC access through an `javax.sql.DataSource` injected like done [here](https://quarkus.io/guides/datasource#consuming-the-datasource).\r\n\r\nImplementation of the repository used to access the DB:\r\n```\r\npublic class PetRepository {\r\n\r\n    @Inject\r\n    PgPool reactiveClient;\r\n\r\n    @Inject\r\n    DataSource jdbcDataSource;\r\n    \r\n    private static final String SELECT_ALL_PETS_QUERY = \"SELECT * FROM pets\";\r\n\r\n    public List<Pet> findAllAwait() {\r\n        List<Pet> pets = new ArrayList<>();\r\n        RowSet<Row> rowSet = reactiveClient.preparedQuery(SELECT_ALL_PETS_QUERY).executeAndAwait();\r\n        for (Row row : rowSet) {\r\n            pets.add(from(row));\r\n        }\r\n        return pets;\r\n    }\r\n\r\n    public List<Pet> findAllBlocking() {\r\n        List<Pet> pets = new ArrayList<>();\r\n        try (Connection connection = jdbcDataSource.getConnection()) {\r\n            try (PreparedStatement statement = connection.prepareStatement(SELECT_ALL_PETS_QUERY)) {\r\n                var result = statement.executeQuery();\r\n                while (result.next()) {\r\n                    pets.add(new Pet(result.getLong(\"id\"), result.getString(\"name\")));\r\n                }\r\n            }\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return pets;\r\n    }\r\n\r\n    public Uni<List<Pet>> findAllReactive() {\r\n        return reactiveClient.preparedQuery(SELECT_ALL_PETS_QUERY).execute().map(rows -> {\r\n            List<Pet> ret = new ArrayList<>(rows.size());\r\n            for (Row row : rows) {\r\n                ret.add(Pet.from(row));\r\n            }\r\n            return ret;\r\n        });\r\n    }\r\n}\r\n```\r\n\r\nThe database and the Quarkus application both run in Docker containers.\r\n\r\nNow after running a few different loads with wrk2 I'm observing some weird results even when repeating the same command multiple times to warm up. Example wrk2 command:\r\n`wrk -t 10 -c 1000 -d30s -R 5000 --latency http://localhost:8080/pets/blocking`\r\n\r\nFor some reason the blocking version achieves the best performance, which I don't have an explanation for. At first, I thought this was due to the reactive connection pool size which defaults to fewer connections than the JDBC pool (20). However, after setting the reactive pool size also to 20 I'm still getting the same results. Everything runs on the same machine for now though so my results are most likely skewed. I constrained the container CPU and memory usage to try to make the application the bottleneck and not the database or the loader.\r\nStill, does someone see anything wrong with my code or the configuration which could explain this? The full project is located here: https://github.com/ozeil/quarkus-loom\r\n\r\nAnother issue I ran into is when I wanted to use `quarkus-netty-loom-adaptor` to increase the virtual thread performance. I'm not sure if I followed the instructions from [@anavarr](https://quarkus.io/guides/virtual-threads#our-solution-to-the-netty-problem) corectly. Have a look at my pom:\r\n\r\n```\r\n<?xml version=\"1.0\"?>\r\n<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n  <groupId>com.oz.loomtest</groupId>\r\n  <artifactId>quarkus-loom</artifactId>\r\n  <version>1.0.0-SNAPSHOT</version>\r\n  <properties>\r\n    <compiler-plugin.version>3.10.1</compiler-plugin.version>\r\n    <maven.compiler.source>19</maven.compiler.source>\r\n    <maven.compiler.target>19</maven.compiler.target>\r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\r\n    <quarkus.platform.artifact-id>quarkus-bom</quarkus.platform.artifact-id>\r\n    <quarkus.platform.group-id>io.quarkus.platform</quarkus.platform.group-id>\r\n    <quarkus.platform.version>2.15.2.Final</quarkus.platform.version>\r\n    <skipITs>true</skipITs>\r\n    <surefire-plugin.version>3.0.0-M7</surefire-plugin.version>\r\n  </properties>\r\n  <dependencyManagement>\r\n    <dependencies>\r\n      <dependency>\r\n        <groupId>${quarkus.platform.group-id}</groupId>\r\n        <artifactId>${quarkus.platform.artifact-id}</artifactId>\r\n        <version>${quarkus.platform.version}</version>\r\n        <type>pom</type>\r\n        <scope>import</scope>\r\n      </dependency>\r\n    </dependencies>\r\n  </dependencyManagement>\r\n  <dependencies>\r\n    <dependency>\r\n      <groupId>io.quarkus</groupId>\r\n      <artifactId>quarkus-resteasy-reactive</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>io.quarkus</groupId>\r\n      <artifactId>quarkus-resteasy-reactive-jackson</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>io.quarkus</groupId>\r\n      <artifactId>quarkus-reactive-pg-client</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>io.quarkus</groupId>\r\n      <artifactId>quarkus-netty-loom-adaptor</artifactId>\r\n      <version>2.15.3.Final</version>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>io.quarkus</groupId>\r\n      <artifactId>quarkus-arc</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>io.quarkus</groupId>\r\n      <artifactId>quarkus-agroal</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>io.quarkus</groupId>\r\n      <artifactId>quarkus-jdbc-postgresql</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>io.quarkus</groupId>\r\n      <artifactId>quarkus-container-image-jib</artifactId>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>io.quarkus</groupId>\r\n      <artifactId>quarkus-junit5</artifactId>\r\n      <scope>test</scope>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>io.rest-assured</groupId>\r\n      <artifactId>rest-assured</artifactId>\r\n      <scope>test</scope>\r\n    </dependency>\r\n  </dependencies>\r\n  <build>\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>${quarkus.platform.group-id}</groupId>\r\n        <artifactId>quarkus-maven-plugin</artifactId>\r\n        <version>${quarkus.platform.version}</version>\r\n        <configuration>\r\n          <source>${maven.compiler.source}</source>\r\n          <target>${maven.compiler.target}</target>\r\n          <!-- are these actually passed to javac??? -->\r\n          <compilerArgs>\r\n            <arg>--enable-preview</arg>\r\n            <arg>-Dnet.bytebuddy.experimental</arg>\r\n          </compilerArgs>\r\n          <jvmArgs>--enable-preview -Djdk.tracePinnedThreads=full --add-opens java.base/java.lang=ALL-UNNAMED</jvmArgs>\r\n        </configuration>\r\n        <extensions>true</extensions>\r\n        <executions>\r\n          <execution>\r\n            <goals>\r\n              <goal>build</goal>\r\n              <goal>generate-code</goal>\r\n            </goals>\r\n          </execution>\r\n        </executions>\r\n      </plugin>\r\n    </plugins>\r\n  </build>\r\n</project>\r\n\r\n```\r\n\r\nI'm not sure if the quarkus-maven-plugin passes the compiler arguments correctly and I'm not sure how to verify this. I see maven outputting `[INFO] [io.quarkus.netty.loom.adaptor.NettyLoomAdaptorProcessor] Adapting Netty for Loom...`. However, this is also the case when I comment out the compilerArgs.\r\nI also tried using maven-compiler-plugin and passing the two compiler arguments there directly like this:\r\n\r\n```\r\n<plugin>\r\n      <groupId>org.apache.maven.plugins</groupId>\r\n      <artifactId>maven-compiler-plugin</artifactId>\r\n      <version>3.8.1</version>\r\n      <configuration>\r\n        <compilerArgs>\r\n          <arg>--enable-preview</arg>\r\n          <arg>-Dnet.bytebuddy.experimental</arg>\r\n        </compilerArgs>\r\n      </configuration>\r\n</plugin>\r\n```\r\nHowever, maven then fails with a fatal error because it doesn't recognize the option -Dnet.bytebuddy.experimental.\r\nBy the way, is it at all necessary to pass --enable-preview to the compiler? In the Quarkus virtual thread guide this is only mentioned in the _Concerning dev mode_ section.\r\n\r\nThank you!\r\n\r\nEDIT:\r\n\r\nNow reran on a proper setup with dedicated hosts for Quarkus app, loader and database. The hosts are located in the same data centre so the latency between all three is quite small.\r\nI'm still getting the best throughput and latencies for the blocking endpoint. Especially latency numbes are way worse with the reactive version. I also noticed much higher CPU usage on the database when the reactive version is ran.",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/30598/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/30598/timeline",
  "performed_via_github_app": null,
  "state_reason": "not_planned"
}
