{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/31417",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/31417/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/31417/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/31417/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/31417",
  "id": 1599729617,
  "node_id": "I_kwDOCFbutM5fWe_R",
  "number": 31417,
  "title": "OpenTelemetry context not propagated to a fork-join pool thread via the `OpenTelemetryMpContextPropagation`",
  "labels": [
    {
      "id": 2236031412,
      "node_id": "MDU6TGFiZWwyMjM2MDMxNDEy",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/tracing",
      "name": "area/tracing",
      "color": "0366d6",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "milestone": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/milestones/235",
    "html_url": "https://github.com/quarkusio/quarkus/milestone/235",
    "labels_url": "https://api.github.com/repos/quarkusio/quarkus/milestones/235/labels",
    "id": 9025446,
    "node_id": "MI_kwDOCFbutM4Aibem",
    "number": 235,
    "title": "3.0.0.Alpha5",
    "description": "",
    "creator": {
      "login": "gsmet",
      "id": 1279749,
      "node_id": "MDQ6VXNlcjEyNzk3NDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1279749?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gsmet",
      "html_url": "https://github.com/gsmet",
      "followers_url": "https://api.github.com/users/gsmet/followers",
      "following_url": "https://api.github.com/users/gsmet/following{/other_user}",
      "gists_url": "https://api.github.com/users/gsmet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gsmet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gsmet/subscriptions",
      "organizations_url": "https://api.github.com/users/gsmet/orgs",
      "repos_url": "https://api.github.com/users/gsmet/repos",
      "events_url": "https://api.github.com/users/gsmet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gsmet/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 0,
    "closed_issues": 253,
    "state": "closed",
    "created_at": "2023-02-09T14:26:03Z",
    "updated_at": "2023-11-12T17:44:08Z",
    "due_on": null,
    "closed_at": "2023-03-08T15:10:59Z"
  },
  "comments": 22,
  "created_at": "2023-02-25T14:44:05Z",
  "updated_at": "2023-03-03T10:16:01Z",
  "closed_at": "2023-03-02T14:26:34Z",
  "active_lock_reason": null,
  "body": "While porting the [Strimzi HTTP - Kafka bridge](https://github.com/strimzi/strimzi-kafka-bridge) from pure Vert.x to Quarkus (using RESTeasy Reactive) I need OpenTelemetry context propagation across threads.\r\n\r\nIn our code, a REST call is executed in the Vert.x event loop which brings the OTel context (with the HTTP call span) within the Vert.x context. The REST call then uses `CompletableFuture.supplyAsync` to run a Kafka client call (in order to free the Vert.x loop soon) which uses an interceptor (from the OpenTelementry Kafka instrumentation library) to add its own span which has to be a child of the HTTP call span.\r\nThe problem is that the original OTel context is not propagated in the fork-join pool thread, where the Kafka call runs.\r\n\r\nIn order to do that I found that:\r\n\r\n* I can use a `ManagedExecutor` instance to run the `CompletableFuture.supplyAsync` code in a Quarkus pool related thread and the OTel context is propagated correctly.\r\n* I can run the REST call using `@Blocking` annotation. Not using the `CompletableFuture.supplyAsync` and running everything in the same worker thread (not using the Vert.x event loop at all).\r\n* I found the `OpenTelemetryMpContextPropagation` (coming in Quarkus 3.0.0) which should help to do the same by capturing the context with `threadContext.withContextCapture` on the `CompletableFuture.supplyAsync` call.\r\n\r\nWhile the first two options work, the third one doesn't.\r\nIf I understood the purpose of the `OpenTelemetryMpContextPropagation`, my expectation was that the OTel context is propagated from a Quarkus managed thread (i.e. Vert.x event loop, any worker thread, ...) to a fork-join pool as well but it seems not happening.\r\nIn our code, the Kafka related span is not attached as child of the HTTP request span, because of the OTel context not propagated (because of missing Vert.x context) . I was able to see why and replicated in the `OpenTelemetryMpContextPropagationTest` just by printing the trace and span ids this way.\r\n\r\n```java\r\n@GET\r\n        @Path(\"/helloWithContextPropagation\")\r\n        public CompletionStage<String> helloWithCustomExecutor() {\r\n            System.out.println(\"Thread \" + Thread.currentThread() + \" ----> \"\r\n                    + Span.current().getSpanContext().getTraceId() + \" - \"\r\n                    + Span.current().getSpanContext().getSpanId());\r\n            String message = \"Hello/\" + Span.current().getSpanContext().getTraceId();\r\n            return this.threadContext\r\n                    .withContextCapture(CompletableFuture.supplyAsync(\r\n                            () -> {\r\n                                System.out.println(\"Thread \" + Thread.currentThread() + \" ----> \"\r\n                                        + Span.current().getSpanContext().getTraceId() + \" - \"\r\n                                        + Span.current().getSpanContext().getSpanId());\r\n                                return message;\r\n                            }, this.customExecutorService))\r\n                    .thenApplyAsync(msg -> {\r\n                        System.out.println(\"Thread \" + Thread.currentThread() + \" ----> \"\r\n                                + Span.current().getSpanContext().getTraceId() + \" - \"\r\n                                + Span.current().getSpanContext().getSpanId());\r\n                        return msg + \"-\" + Span.current().getSpanContext().getTraceId();\r\n                    });\r\n        }\r\n````\r\n\r\nThe output is something like this:\r\n\r\n```shell\r\nThread Thread[executor-thread-0,5,main] ----> 249af904b222cf7684706bedbb0a26ff - 943063dd4c81d983\r\nThread Thread[ForkJoinPool-1-worker-19,5,main] ----> 00000000000000000000000000000000 - 0000000000000000\r\nThread Thread[executor-thread-1,5,main] ----> 249af904b222cf7684706bedbb0a26ff - 943063dd4c81d983\r\n```\r\n\r\nAs you can see the OTel context is not propagated in the fork-join pool thread, not managed by Quarkus, and it returns to be available in the `thenApplyAsync` because the code is executed in some Quarkus managed thread, I guess.\r\nAFAIU, the purpose of the `OpenTelemetryMpContextPropagation` was to make OTel context available across threads even if not managed by Quarkus, so not propagated by a Vert.x context.\r\nIs there anything I misunderstood about the usage of `OpenTelemetryMpContextPropagation`, or is it a bug?\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/31417/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/31417/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
