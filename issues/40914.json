{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/40914",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/40914/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/40914/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/40914/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/40914",
  "id": 2327082328,
  "node_id": "I_kwDOCFbutM6KtHVY",
  "number": 40914,
  "title": "Clarify kafka commit strategy \"latest\" in documentation",
  "labels": [
    {
      "id": 985346622,
      "node_id": "MDU6TGFiZWw5ODUzNDY2MjI=",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/kind/enhancement",
      "name": "kind/enhancement",
      "color": "a2eeef",
      "default": false,
      "description": "New feature or request"
    },
    {
      "id": 1658790125,
      "node_id": "MDU6TGFiZWwxNjU4NzkwMTI1",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/kafka",
      "name": "area/kafka",
      "color": "0366d6",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "milestone": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/milestones/333",
    "html_url": "https://github.com/quarkusio/quarkus/milestone/333",
    "labels_url": "https://api.github.com/repos/quarkusio/quarkus/milestones/333/labels",
    "id": 11151112,
    "node_id": "MI_kwDOCFbutM4AqicI",
    "number": 333,
    "title": "3.11.2",
    "description": "",
    "creator": {
      "login": "gsmet",
      "id": 1279749,
      "node_id": "MDQ6VXNlcjEyNzk3NDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1279749?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gsmet",
      "html_url": "https://github.com/gsmet",
      "followers_url": "https://api.github.com/users/gsmet/followers",
      "following_url": "https://api.github.com/users/gsmet/following{/other_user}",
      "gists_url": "https://api.github.com/users/gsmet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gsmet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gsmet/subscriptions",
      "organizations_url": "https://api.github.com/users/gsmet/orgs",
      "repos_url": "https://api.github.com/users/gsmet/repos",
      "events_url": "https://api.github.com/users/gsmet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gsmet/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 0,
    "closed_issues": 29,
    "state": "closed",
    "created_at": "2024-06-06T16:06:20Z",
    "updated_at": "2024-08-14T12:08:46Z",
    "due_on": null,
    "closed_at": "2024-06-12T17:57:35Z"
  },
  "comments": 5,
  "created_at": "2024-05-31T06:46:05Z",
  "updated_at": "2024-06-17T04:12:57Z",
  "closed_at": "2024-06-05T12:32:54Z",
  "active_lock_reason": null,
  "body": "### Description\n\nhttps://quarkus.io/guides/kafka#commit-strategies states \"This strategy provides at-least-once delivery if the channel processes the message without performing any asynchronous processing.\". According to this [discussion ](https://quarkusio.zulipchat.com/#narrow/stream/294206-smallrye/topic/kafka.20override.20commit-strategy.20default.20for.20all.20channels/near/441036327), this should be read as \"if the channel processes the message without performing any asynchronous processing, there could be message loss\".\r\nmessage loss is bad enough for many applications, that I believe it should be stated explicitly. and \"asynchronous processing\" should be clearly explained. are we talking about reactive style programming? or running subtasks on an executor service and acknowledging the message without waiting for the result? or doing straight processing with concurrency on (e.g. `Blocking` with `ordered=false`, or `@RunOnVirtualThread`)?\r\n\r\nI ran some tests to verify the latest. I have a producer that pushes 5 messages per seconds. and a consumer that processes them with `@RunOnVirtualThread` printing simulating some processing with a sleep between 0 and 1000 ms, and printing ids in a file. from time to time I kill the consumer and restart. Separately I have a checker that reads the file with the ids and check that there may be some duplicates but no holes. \r\nI was able to verify that with commit strategies `throttled` and `latest` I did not have any message loss. which is good news. but the question remains: what asynchronous processing are we talking about?\n\n### Implementation ideas\n\n_No response_",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/40914/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/40914/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
