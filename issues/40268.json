{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/40268",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/40268/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/40268/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/40268/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/40268",
  "id": 2262878592,
  "node_id": "I_kwDOCFbutM6G4MmA",
  "number": 40268,
  "title": "State cookies (q_auth) keeps piling up in code flow",
  "labels": [
    {
      "id": 985346620,
      "node_id": "MDU6TGFiZWw5ODUzNDY2MjA=",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/kind/bug",
      "name": "kind/bug",
      "color": "d73a4a",
      "default": false,
      "description": "Something isn't working"
    },
    {
      "id": 1479557456,
      "node_id": "MDU6TGFiZWwxNDc5NTU3NDU2",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/oidc",
      "name": "area/oidc",
      "color": "0366d6",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "milestone": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/milestones/323",
    "html_url": "https://github.com/quarkusio/quarkus/milestone/323",
    "labels_url": "https://api.github.com/repos/quarkusio/quarkus/milestones/323/labels",
    "id": 10825140,
    "node_id": "MI_kwDOCFbutM4ApS20",
    "number": 323,
    "title": "3.11.0.CR1",
    "description": "",
    "creator": {
      "login": "quarkusbot",
      "id": 61254497,
      "node_id": "MDQ6VXNlcjYxMjU0NDk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/61254497?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quarkusbot",
      "html_url": "https://github.com/quarkusbot",
      "followers_url": "https://api.github.com/users/quarkusbot/followers",
      "following_url": "https://api.github.com/users/quarkusbot/following{/other_user}",
      "gists_url": "https://api.github.com/users/quarkusbot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quarkusbot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quarkusbot/subscriptions",
      "organizations_url": "https://api.github.com/users/quarkusbot/orgs",
      "repos_url": "https://api.github.com/users/quarkusbot/repos",
      "events_url": "https://api.github.com/users/quarkusbot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quarkusbot/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 0,
    "closed_issues": 180,
    "state": "closed",
    "created_at": "2024-04-16T10:59:06Z",
    "updated_at": "2024-08-07T12:38:09Z",
    "due_on": null,
    "closed_at": "2024-05-15T13:36:12Z"
  },
  "comments": 7,
  "created_at": "2024-04-25T07:24:55Z",
  "updated_at": "2024-04-26T17:30:49Z",
  "closed_at": "2024-04-26T17:30:46Z",
  "active_lock_reason": null,
  "body": "### Describe the bug\n\nQuarkus does not properly manage existing q_auth cookies during the OIDC code flow in web applications. When the OIDC code flow is triggered (e.g., upon access token expiration), Quarkus generates a new q_auth cookie without considering if one already exists. This results in multiple q_auth cookies accumulating in the user's browser over time.\n\n### Expected behavior\n\nQuarkus should check for existing q_auth cookies before generating a new one during the OIDC code flow. If an existing q_auth cookie is found, it should either be reused or invalidated before a new cookie is created. This approach would prevent the accumulation of q_auth cookies in the user's browser.\n\n### Actual behavior\n\nWhenever the OIDC code flow is initiated by Quarkus, a new q_auth cookie is created regardless of whether a similar cookie already exists. This leads to an accumulation of q_auth cookies, particularly noticeable in scenarios with frequent token expirations and renewals, such as when a heartbeat mechanism in the frontend continuously calls an endpoint after the access token expires. Eventually, this accumulation can cause the browser to send an HTTP 431 error due to oversized request headers.\n\n### How to Reproduce?\n\n1. Set up a Quarkus application with OIDC code flow authentication.\r\n2. Implement a frontend heartbeat mechanism that continuously calls a backend endpoint using the current access token.\r\n3. Allow the access token to expire, triggering the OIDC code flow repeatedly through the heartbeat calls.\r\n4. Observe the accumulation of q_auth cookies as each new token expiration leads to a new code flow initiation.\r\n5. After multiple heartbeat cycles and token expirations, attempt to access the application and observe an HTTP 431 error (Request Header Fields Too Large), indicative of too many q_auth cookies.\n\n### Output of `uname -a` or `ver`\n\n_No response_\n\n### Output of `java -version`\n\n_No response_\n\n### Quarkus version or git rev\n\n_No response_\n\n### Build tool (ie. output of `mvnw --version` or `gradlew --version`)\n\n_No response_\n\n### Additional information\n\nTemporary Solution\r\nWe have implemented a workaround by extending the default OidcAuthenticationMechanism. In the overridden getChallenge method, we explicitly check for and expire any existing q_auth cookies before proceeding with the default Quarkus OIDC implementation.\r\n\r\n```\r\n@Alternative\r\n@Priority(1)\r\n@ApplicationScoped\r\npublic class CustomOidcAuthenticationMechanism implements HttpAuthenticationMechanism {\r\n    @Inject\r\n    OidcAuthenticationMechanism oidcAuthenticationMechanism;\r\n\r\n    @Override\r\n    public Uni<SecurityIdentity> authenticate(RoutingContext context, IdentityProviderManager identityProviderManager) {\r\n        return oidcAuthenticationMechanism.authenticate(context, identityProviderManager);\r\n    }\r\n\r\n    @Override\r\n    public Uni<ChallengeData> getChallenge(RoutingContext context) {\r\n        System.out.println(\"custom getChallenge\");\r\n        context.request().cookies().stream()\r\n                .filter(cookie -> cookie.getName().startsWith(OidcUtils.STATE_COOKIE_NAME))\r\n                .forEach(cookie -> {\r\n                    System.out.println(\"expire cookie: \" + cookie.getName());\r\n                    context.response().addCookie(Cookie.cookie(cookie.getName(), cookie.getValue()).setPath(cookie.getPath()).setMaxAge(0));\r\n                });\r\n\r\n        return oidcAuthenticationMechanism.getChallenge(context);\r\n    }\r\n}\r\n```\r\n\r\nSuggestion for Quarkus Improvement\r\nIt would be beneficial for Quarkus to incorporate a similar check and handling mechanism for q_auth cookies directly within its default OIDC authentication mechanisms to prevent this issue from affecting other users.\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/40268/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/40268/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
