{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/34146",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/34146/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/34146/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/34146/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/34146",
  "id": 1764122109,
  "node_id": "I_kwDOCFbutM5pJl39",
  "number": 34146,
  "title": "BlockingOperationNotAllowedException in GRPC when using authentication",
  "labels": [
    {
      "id": 985346620,
      "node_id": "MDU6TGFiZWw5ODUzNDY2MjA=",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/kind/bug",
      "name": "kind/bug",
      "color": "d73a4a",
      "default": false,
      "description": "Something isn't working"
    },
    {
      "id": 1676631606,
      "node_id": "MDU6TGFiZWwxNjc2NjMxNjA2",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/env/windows",
      "name": "env/windows",
      "color": "edea47",
      "default": false,
      "description": "Impacts Windows machines"
    },
    {
      "id": 2062531368,
      "node_id": "MDU6TGFiZWwyMDYyNTMxMzY4",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/grpc",
      "name": "area/grpc",
      "color": "0366d6",
      "default": false,
      "description": "gRPC"
    }
  ],
  "state": "closed",
  "locked": false,
  "milestone": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/milestones/261",
    "html_url": "https://github.com/quarkusio/quarkus/milestone/261",
    "labels_url": "https://api.github.com/repos/quarkusio/quarkus/milestones/261/labels",
    "id": 9620417,
    "node_id": "MI_kwDOCFbutM4AksvB",
    "number": 261,
    "title": "3.2.1.Final",
    "description": "",
    "creator": {
      "login": "gsmet",
      "id": 1279749,
      "node_id": "MDQ6VXNlcjEyNzk3NDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1279749?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gsmet",
      "html_url": "https://github.com/gsmet",
      "followers_url": "https://api.github.com/users/gsmet/followers",
      "following_url": "https://api.github.com/users/gsmet/following{/other_user}",
      "gists_url": "https://api.github.com/users/gsmet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gsmet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gsmet/subscriptions",
      "organizations_url": "https://api.github.com/users/gsmet/orgs",
      "repos_url": "https://api.github.com/users/gsmet/repos",
      "events_url": "https://api.github.com/users/gsmet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gsmet/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 0,
    "closed_issues": 137,
    "state": "closed",
    "created_at": "2023-07-05T15:27:44Z",
    "updated_at": "2023-08-07T13:21:27Z",
    "due_on": null,
    "closed_at": "2023-07-19T13:26:50Z"
  },
  "comments": 7,
  "created_at": "2023-06-19T19:39:01Z",
  "updated_at": "2023-07-05T15:43:57Z",
  "closed_at": "2023-07-05T06:53:53Z",
  "active_lock_reason": null,
  "body": "### Describe the bug\r\n\r\nDear all, \r\nI'm implementing a solution to use a jwt bearer with GRPC.\r\nI've created a class JWTGrpcSecurityMechanism that extends GrpcSecurityMechanism\r\n```\r\n@ApplicationScoped\r\npublic class JWTGrpcSecurityMechanism implements GrpcSecurityMechanism {\r\n\r\n\t@Override\r\n\tpublic boolean handles(Metadata metadata) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic AuthenticationRequest createAuthenticationRequest(Metadata metadata) {\r\n\t\tString jwt = metadata.get(io.grpc.Metadata.Key.of(\"authorization\", Metadata.ASCII_STRING_MARSHALLER));\r\n\t\tjwt = jwt.substring(\"Bearer \".length());\r\n\t\tTokenAuthenticationRequest token = new TokenAuthenticationRequest(new JsonWebTokenCredential(jwt));\r\n\t\treturn token;\r\n\t}\r\n\r\n}\r\n```\r\nIf I execute a client call with a right bearer I receive this error.\r\n```\r\nio.quarkus.runtime.BlockingOperationNotAllowedException: You have attempted to perform a blocking operation on a IO thread. This is not allowed, as blocking the IO thread will cause major performance issues with your application. If you want to perform blocking EntityManager operations make sure you are doing it from a worker thread.\r\n\tat io.quarkus.hibernate.orm.runtime.session.TransactionScopedSession.checkBlocking(TransactionScopedSession.java:116)\r\n\tat io.quarkus.hibernate.orm.runtime.session.TransactionScopedSession.find(TransactionScopedSession.java:173)\r\n\tat org.hibernate.engine.spi.SessionLazyDelegator.find(SessionLazyDelegator.java:784)\r\n\tat org.hibernate.Session_3a974b6a18ac399f675913d732c105426414d370_Synthetic_ClientProxy.find(Unknown Source)\r\n```\r\n\r\n\r\nThis seems to be due to the io.quarkus.grpc.auth.GrpcSecurityInterceptor where it execute the chain, when the authentication is OK, using the context thread (I/O thread):\r\n\r\n```\r\n        for (GrpcSecurityMechanism securityMechanism : securityMechanisms) {\r\n            if (securityMechanism.handles(metadata)) {\r\n                try {\r\n                    AuthenticationRequest authenticationRequest = securityMechanism.createAuthenticationRequest(metadata);\r\n                    Context context = Vertx.currentContext();\r\n                    boolean onEventLoopThread = Context.isOnEventLoopThread();\r\n                    if (authenticationRequest != null) {\r\n                        Uni<SecurityIdentity> auth = identityProviderManager\r\n                                .authenticate(authenticationRequest)\r\n                                .emitOn(new Executor() {\r\n                                    @Override\r\n                                    public void execute(Runnable command) {\r\n                                        if (onEventLoopThread) {\r\n                                            context.runOnContext(new Handler<>() {\r\n                                                @Override\r\n                                                public void handle(Void event) {\r\n                                                    command.run();\r\n                                                }\r\n                                            });\r\n                                        } else {\r\n                                            command.run();\r\n                                        }\r\n                                    }\r\n                                });\r\n````\r\n\r\nThis code dones not take in consideration the @Blocking annotation in the grpc implementation\r\n\r\n```\r\n@Authenticated\r\n@Blocking\r\n@GrpcService\r\npublic class SurveyServiceImpl implements SurveyService{\r\n\r\n\t@Inject\r\n\tprivate be.digitech.common.survey.service.SurveyService surveyService;\r\n\r\n\r\n\t@Override\r\n\tpublic Uni<SurveyValidationResult> validate(SurveyResponses request) {\r\n\t\treturn Uni.createFrom().item(()-> {\r\n\t\t\ttry {\r\n\t\t\t\tthis.surveyService.validate(request.getSurveyName(), request.getSurveyId(), request.getResponsesMap());\r\n\t\t\t\treturn SurveyValidationResult.newBuilder().setResultCode(SurveyValidationResultCode.OK).build();\r\n\t\t\t}catch (ValidationException e) {\r\n\t\t\t\treturn SurveyMapper.toSurveyValidationResult(e);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n```\r\n\r\nand the system goes in error.\r\n\r\nIf I remove the @Authenticated annotation, all work fine.\r\n\r\nSorry if I am not very clear.\r\nI'm at disposal for every explaination\r\n\r\n### Expected behavior\r\n\r\nThe system must execute the GRPC service implementation in an worker thread if I use the @Blocking annotation.\r\n\r\n### Actual behavior\r\n\r\nThe system uses the I/O thread used during the authentication process also if I set the @Blocking annotation in the implementation class.\r\n```\r\n                   AuthenticationRequest authenticationRequest = securityMechanism.createAuthenticationRequest(metadata);\r\n                    Context context = Vertx.currentContext();\r\n                    boolean onEventLoopThread = Context.isOnEventLoopThread(); // this returns true and the thread is a I/O thread\r\n...\r\n                                .authenticate(authenticationRequest)\r\n                                .emitOn(new Executor() {\r\n                                    @Override\r\n                                    public void execute(Runnable command) {\r\n                                        if (onEventLoopThread) { // enters in this if\r\n                                            context.runOnContext(new Handler<>() { //executes in the context thread\r\n                                                @Override\r\n                                                public void handle(Void event) {\r\n                                                    command.run();\r\n                                                }\r\n                                            });\r\n                                        } else {\r\n                                            command.run();\r\n                                        }\r\n                                    }\r\n                                });\r\n\r\n```\r\n\r\n### How to Reproduce?\r\n\r\nPre-requirements:\r\n\r\n- a quarkus project with GRPC and postgres features\r\n- a proto with a RPC service \r\n- The RPC implementation must execute a findById in panache\r\n- You have to implement a GrpcSecurityMechanism that returns an AuthenticationRequest\r\n```\r\n@ApplicationScoped\r\npublic class JWTGrpcSecurityMechanism implements GrpcSecurityMechanism {\r\n\r\n\t@Override\r\n\tpublic boolean handles(Metadata metadata) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic AuthenticationRequest createAuthenticationRequest(Metadata metadata) {\r\n\t\tString jwt = metadata.get(io.grpc.Metadata.Key.of(\"authorization\", Metadata.ASCII_STRING_MARSHALLER));\r\n\t\tjwt = jwt.substring(\"Bearer \".length());\r\n\t\tTokenAuthenticationRequest token = new TokenAuthenticationRequest(new JsonWebTokenCredential(jwt));\r\n\t\treturn token;\r\n\t}\r\n\r\n}\r\n```\r\n\r\n- you have to call the grpc request with a right bearer jwt token \r\n\r\n### Output of `uname -a` or `ver`\r\n\r\nWindows 10\r\n\r\n### Output of `java -version`\r\n\r\njava version \"17.0.5\" 2022-10-18 LTS\r\n\r\n### GraalVM version (if different from Java)\r\n\r\n_No response_\r\n\r\n### Quarkus version or git rev\r\n\r\n3.0.1.Final\r\n\r\n### Build tool (ie. output of `mvnw --version` or `gradlew --version`)\r\n\r\nApache Maven 3.9.1 (2e178502fcdbffc201671fb2537d0cb4b4cc58f8)\r\n\r\n### Additional information\r\n\r\n_No response_",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/34146/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/34146/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
