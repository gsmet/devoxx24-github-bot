{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/33994",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/33994/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/33994/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/33994/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/33994",
  "id": 1753444717,
  "node_id": "I_kwDOCFbutM5og3Ft",
  "number": 33994,
  "title": "Allow token propagation filters to be used within the SecurityIdentityAugmentor",
  "labels": [
    {
      "id": 985346622,
      "node_id": "MDU6TGFiZWw5ODUzNDY2MjI=",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/kind/enhancement",
      "name": "kind/enhancement",
      "color": "a2eeef",
      "default": false,
      "description": "New feature or request"
    },
    {
      "id": 1282139374,
      "node_id": "MDU6TGFiZWwxMjgyMTM5Mzc0",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/security",
      "name": "area/security",
      "color": "0366d6",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "milestone": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/milestones/255",
    "html_url": "https://github.com/quarkusio/quarkus/milestone/255",
    "labels_url": "https://api.github.com/repos/quarkusio/quarkus/milestones/255/labels",
    "id": 9565017,
    "node_id": "MI_kwDOCFbutM4AkfNZ",
    "number": 255,
    "title": "3.3.0.CR1",
    "description": "",
    "creator": {
      "login": "gsmet",
      "id": 1279749,
      "node_id": "MDQ6VXNlcjEyNzk3NDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1279749?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gsmet",
      "html_url": "https://github.com/gsmet",
      "followers_url": "https://api.github.com/users/gsmet/followers",
      "following_url": "https://api.github.com/users/gsmet/following{/other_user}",
      "gists_url": "https://api.github.com/users/gsmet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gsmet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gsmet/subscriptions",
      "organizations_url": "https://api.github.com/users/gsmet/orgs",
      "repos_url": "https://api.github.com/users/gsmet/repos",
      "events_url": "https://api.github.com/users/gsmet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gsmet/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 0,
    "closed_issues": 310,
    "state": "closed",
    "created_at": "2023-06-21T07:35:19Z",
    "updated_at": "2024-05-17T05:53:43Z",
    "due_on": null,
    "closed_at": "2023-08-09T11:23:12Z"
  },
  "comments": 4,
  "created_at": "2023-06-12T19:39:05Z",
  "updated_at": "2023-08-02T15:22:50Z",
  "closed_at": "2023-07-27T21:56:32Z",
  "active_lock_reason": null,
  "body": "### Description\n\nI tried to write a SecurityIdentityAugmentor that reuses the JWT to check with another service for a set of roles, since the JWT doesn't have the complete set of roles in this envrionment.\r\n\r\nInitially, I tried to write a simple Quarkus REST client that used the `AccessTokenRequestReactiveFilter` and would get the JWT injected into the HTTP Bearer header, but that filter was unable to see a token in the context.\r\n\r\nI found some StackOverflow hints that suggested I could strip the raw token from the identity and then wire up the REST client to just toss the token in the HTTP Bearer header, but this feels wrong. It seems like I should be able to wire up Quarkus to do this for me.\r\n\r\nThis is the code I've come up with, where I'm doing the work of `@RegisterProvider(AccessTokenRequestReactiveFilter.class)`:\r\n```java\r\n  @Override\r\n  public Uni<SecurityIdentity> augment(SecurityIdentity identity, AuthenticationRequestContext context) {\r\n    return context.runBlocking(build(identity));\r\n  }\r\n\r\n  @Inject\r\n  @RestClient\r\n  protected AuthServiceClient authServiceClient;\r\n\r\n  protected Supplier<SecurityIdentity> build(SecurityIdentity identity) {\r\n    if(identity.isAnonymous()) {\r\n      return () -> identity;\r\n    } else {\r\n      return () -> {\r\n        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder(identity);\r\n        // TODO: way to do this that doesn't involve handling the raw JWT?\r\n        Principal principal = identity.getPrincipal();\r\n        if (principal instanceof JsonWebToken) {\r\n          JsonWebToken jwtToken = (JsonWebToken) principal;\r\n          List<String> roles = authServiceClient.getRoles(jwtToken.getRawToken());\r\n          roles.forEach(builder::addRole);\r\n        }\r\n        return builder.build();\r\n      };\r\n    }\r\n  }\r\n```\r\nAnd then the snippet from the REST client:\r\n```java\r\n  @GET\r\n  @Path(\"/roles\")\r\n  @ClientHeaderParam(name = \"Authorization\", value = \"Bearer {jwtToken}\")\r\n  Uni<List<String>> getRoles(@NotBody String jwtToken)\r\n```\r\n\r\n@sberyozkin suggested that it may be possible \"the token CDI producers can be tweaked a bit not to rely on the injected security identity\" and asked me to open this issue.\n\n### Implementation ideas\n\n_No response_",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/33994/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/33994/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
