{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/30182",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/30182/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/30182/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/30182/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/30182",
  "id": 1519615282,
  "node_id": "I_kwDOCFbutM5ak30y",
  "number": 30182,
  "title": "ServiceConfigurationError when calling async functions on Hazelcast IMap",
  "labels": [
    {
      "id": 985346620,
      "node_id": "MDU6TGFiZWw5ODUzNDY2MjA=",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/kind/bug",
      "name": "kind/bug",
      "color": "d73a4a",
      "default": false,
      "description": "Something isn't working"
    },
    {
      "id": 3700813587,
      "node_id": "LA_kwDOCFbutM7cle8T",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/context-propagation",
      "name": "area/context-propagation",
      "color": "0366d6",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "milestone": null,
  "comments": 0,
  "created_at": "2023-01-04T21:42:42Z",
  "updated_at": "2023-01-05T17:57:49Z",
  "closed_at": null,
  "active_lock_reason": null,
  "body": "### Describe the bug\n\nWe currently have a Quarkus application that uses RestEasy Reactive and integrates with Hazelcast for caching. The caching works initially. However, after a period of time (5-10 minutes) when the code is accessed, a SmallRye exception is thrown. Once thrown, the code path will always fail with the same exception. I've read up on [Context Propagation](https://quarkus.io/guides/context-propagation) and review [other tickets](https://github.com/quarkusio/quarkus/issues/24896), but can't seem to figure out why the correct classloader is not being used. We would appreciate any insight into this that you can provide.\n\n### Expected behavior\n\nI would expect the initial behavior of not throwing an exception to always be the case.\n\n### Actual behavior\n\nAn exception is thrown:\r\n```\r\nERROR [or.jb.re.re.co.co.AbstractResteasyReactiveContext] (vert.x-eventloop-thread-1) Request failed: java.util.ServiceConfigurationError: io.smallrye.config.SmallRyeConfigFactory: io.quarkus.runtime.configuration.QuarkusConfigFactory not a subtype\r\n\tat java.base/java.util.ServiceLoader.fail(ServiceLoader.java:593)\r\n\tat java.base/java.util.ServiceLoader$LazyClassPathLookupIterator.hasNextService(ServiceLoader.java:1244)\r\n\tat java.base/java.util.ServiceLoader$LazyClassPathLookupIterator.hasNext(ServiceLoader.java:1273)\r\n\tat java.base/java.util.ServiceLoader$2.hasNext(ServiceLoader.java:1309)\r\n\tat java.base/java.util.ServiceLoader$3.hasNext(ServiceLoader.java:1393)\r\n\tat io.smallrye.config.SmallRyeConfigProviderResolver.getFactoryFor(SmallRyeConfigProviderResolver.java:100)\r\n\tat io.smallrye.config.SmallRyeConfigProviderResolver.getConfig(SmallRyeConfigProviderResolver.java:76)\r\n\tat io.smallrye.config.SmallRyeConfigProviderResolver.getConfig(SmallRyeConfigProviderResolver.java:64)\r\n\tat org.eclipse.microprofile.config.ConfigProvider.getConfig(ConfigProvider.java:85)\r\n\tat io.smallrye.context.impl.DefaultValues.<init>(DefaultValues.java:41)\r\n\tat io.smallrye.context.SmallRyeContextManager.<init>(SmallRyeContextManager.java:63)\r\n\tat io.smallrye.context.SmallRyeContextManager$Builder.build(SmallRyeContextManager.java:337)\r\n\tat io.smallrye.context.SmallRyeContextManagerProvider.getContextManager(SmallRyeContextManagerProvider.java:48)\r\n\tat io.smallrye.context.SmallRyeContextManagerProvider.getContextManager(SmallRyeContextManagerProvider.java:37)\r\n\tat io.smallrye.context.SmallRyeContextManagerProvider.getManager(SmallRyeContextManagerProvider.java:97)\r\n\tat io.smallrye.context.SmallRyeThreadContext.getCurrentThreadContextOrDefaultContexts(SmallRyeThreadContext.java:160)\r\n\tat io.smallrye.mutiny.context.DefaultContextPropagationInterceptor.getThreadContext(DefaultContextPropagationInterceptor.java:12)\r\n\tat io.smallrye.mutiny.context.BaseContextPropagationInterceptor.decorate(BaseContextPropagationInterceptor.java:24)\r\n\tat io.smallrye.mutiny.infrastructure.Infrastructure.decorate(Infrastructure.java:145)\r\n\tat io.smallrye.mutiny.groups.UniCreate.completionStage(UniCreate.java:142)\r\n\tat io.smallrye.mutiny.groups.UniCreate.completionStage(UniCreate.java:78)\r\n\tat com.floify.cache.Cache.put(Cache.java:69)\r\n\tat com.floify.cache.Cache.lambda$computeIfAbsent$0(Cache.java:95)\r\n\tat io.smallrye.context.impl.wrappers.SlowContextualConsumer.accept(SlowContextualConsumer.java:21)\r\n\tat io.smallrye.mutiny.groups.UniOnNotNull.lambda$invoke$0(UniOnNotNull.java:40)\r\n\tat io.smallrye.context.impl.wrappers.SlowContextualConsumer.accept(SlowContextualConsumer.java:21)\r\n\tat io.smallrye.mutiny.operators.uni.UniOnItemConsume$UniOnItemComsumeProcessor.invokeEventHandler(UniOnItemConsume.java:77)\r\n\tat io.smallrye.mutiny.operators.uni.UniOnItemConsume$UniOnItemComsumeProcessor.onItem(UniOnItemConsume.java:42)\r\n\tat io.smallrye.mutiny.operators.uni.UniOnItemTransformToUni$UniOnItemTransformToUniProcessor.onItem(UniOnItemTransformToUni.java:60)\r\n\tat io.smallrye.mutiny.operators.uni.builders.UniCreateFromKnownItem$KnownItemSubscription.forward(UniCreateFromKnownItem.java:38)\r\n\tat io.smallrye.mutiny.operators.uni.builders.UniCreateFromKnownItem$KnownItemSubscription.access$100(UniCreateFromKnownItem.java:26)\r\n\tat io.smallrye.mutiny.operators.uni.builders.UniCreateFromKnownItem.subscribe(UniCreateFromKnownItem.java:23)\r\n\tat io.smallrye.mutiny.operators.AbstractUni.subscribe(AbstractUni.java:36)\r\n\tat io.smallrye.mutiny.operators.uni.UniOnItemTransformToUni$UniOnItemTransformToUniProcessor.performInnerSubscription(UniOnItemTransformToUni.java:81)\r\n\tat io.smallrye.mutiny.operators.uni.UniOnItemTransformToUni$UniOnItemTransformToUniProcessor.onItem(UniOnItemTransformToUni.java:57)\r\n\tat io.smallrye.mutiny.operators.uni.builders.UniCreateFromCompletionStage$CompletionStageUniSubscription.forwardResult(UniCreateFromCompletionStage.java:63)\r\n\tat io.smallrye.context.impl.wrappers.SlowContextualBiConsumer.accept(SlowContextualBiConsumer.java:21)\r\n\tat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\r\n\tat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\r\n\tat java.base/java.util.concurrent.CompletableFuture$Completion.exec(CompletableFuture.java:483)\r\n\tat java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)\r\n\tat java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)\r\n\tat java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)\r\n\tat java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)\r\n\tat java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)\r\n```\n\n### How to Reproduce?\n\nHere is some of the code:\r\n\r\nHazelcast Producer:\r\n```java\r\npublic class HazelcastClientService {\r\n\r\n  @Produces\r\n  @ApplicationScoped\r\n  @IfBuildProperty(name = \"clustering.aws.enabled\", stringValue = \"false\", enableIfMissing = true)\r\n  HazelcastInstance getDefaultHazelcastClient(final ClusteringConfig config) {\r\n    return HazelcastClient.newHazelcastClient(config.toClientConfig());\r\n  }\r\n\r\n  @Produces\r\n  @ApplicationScoped\r\n  @IfBuildProperty(name = \"clustering.aws.enabled\", stringValue = \"true\")\r\n  HazelcastInstance getAwsHazelcastClient(\r\n      final ClusteringConfig config, final AwsCredentials credentials) {\r\n    return HazelcastClient.newHazelcastClient(config.toClientConfig(credentials));\r\n  }\r\n}\r\n```\r\n\r\nCache manager:\r\n```java\r\n@ApplicationScoped\r\npublic class Caches {\r\n  @Inject HazelcastInstance hazelcast;\r\n  @Inject\r\n  ThreadContext threadContext;\r\n  @Inject\r\n  ManagedExecutor managedExecutor;\r\n  private final ConcurrentMap<String, Cache> backingCaches = new ConcurrentHashMap<>();\r\n\r\n  public Cache<User> getUserByEmailCache() {\r\n    return getCache(\"userByEmailCache\", User.class);\r\n  }\r\n\r\n  public Cache<Team> getTeamByDomainCache() {\r\n    return getCache(\"teamByDomainCache\", Team.class);\r\n  }\r\n\r\n  public Cache<UserState> getUserStateByEmailCache() {\r\n    return getCache(\"userStateByEmailCache\", UserState.class);\r\n  }\r\n\r\n  @SuppressWarnings(\"unchecked\")\r\n  private <T> Cache<T> getCache(final String key, final Class<T> type) {\r\n    Cache<T> cache = backingCaches.get(key);\r\n\r\n    if (cache == null) {\r\n      cache = new Cache<>(threadContext, managedExecutor, hazelcast.getMap(key), type);\r\n\r\n      backingCaches.put(key, cache);\r\n    }\r\n\r\n    return cache;\r\n  }\r\n}\r\n```\r\n\r\nCache:\r\n```java\r\n@Slf4j\r\npublic class Cache<T> {\r\n  protected final IMap<String, String> backingCache;\r\n  @Getter protected final ObjectMapper mapper;\r\n  @Getter protected final Class<T> type;\r\n  private final ThreadContext threadContext;\r\n  private final ManagedExecutor managedExecutor;\r\n\r\n  public Cache(final IMap<String, String> cache, final Class<T> type) {\r\n    this.mapper = new ObjectMapper();\r\n    this.mapper.findAndRegisterModules();\r\n    this.mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r\n\r\n    this.backingCache = cache;\r\n    this.type = type;\r\n    this.threadContext = null;\r\n    this.managedExecutor = null;\r\n  }\r\n\r\n  public Cache(ThreadContext threadContext,\r\n      ManagedExecutor managedExecutor, IMap<String, String> cache, Class<T> type) {\r\n    this.mapper = new ObjectMapper();\r\n    this.mapper.findAndRegisterModules();\r\n    this.mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r\n\r\n    this.backingCache = cache;\r\n    this.type = type;\r\n    this.threadContext = threadContext;\r\n    this.managedExecutor = managedExecutor;\r\n  }\r\n\r\n  public Uni<T> get(final String key) {\r\n    if (StringUtils.isBlank(key)) {\r\n      return Uni.createFrom().nullItem();\r\n    }\r\n\r\n    CompletionStage<T> get = threadContext\r\n        .withContextCapture(backingCache.getAsync(key))\r\n        .thenApplyAsync(this::deserialize, managedExecutor);\r\n\r\n    return Uni.createFrom().completionStage(get);\r\n  }\r\n\r\n  public Uni<T> put(final String key, final T value) {\r\n    if (StringUtils.isBlank(key) || value == null) {\r\n      return Uni.createFrom().nullItem();\r\n    }\r\n\r\n    try {\r\n      CompletionStage<T> put = threadContext\r\n          .withContextCapture(backingCache.putAsync(key, mapper.writeValueAsString(value)))\r\n          .thenApplyAsync(this::deserialize, managedExecutor);\r\n\r\n      return Uni.createFrom().completionStage(put);\r\n    } catch (JsonProcessingException exception) {\r\n      log.error(\"Could not serialize object for key {}\", key, exception);\r\n\r\n      return Uni.createFrom().failure(exception);\r\n    }\r\n  }\r\n\r\n  public Uni<T> delete(final String key) {\r\n    if (StringUtils.isBlank(key)) {\r\n      return Uni.createFrom().nullItem();\r\n    }\r\n\r\n    CompletionStage<T> delete = threadContext\r\n        .withContextCapture(backingCache.removeAsync(key))\r\n        .thenApplyAsync(this::deserialize, managedExecutor);\r\n\r\n    return Uni.createFrom().completionStage(delete);\r\n  }\r\n\r\n  public Uni<T> computeIfAbsent(final String key, final Supplier<Uni<T>> computer) {\r\n    // spotless:off\r\n    return get(key)\r\n        .onItem()\r\n        .ifNull().switchTo(computer::get)\r\n        .onItem()\r\n        .ifNotNull().invoke(value -> put(key, value));\r\n    // spotless:on\r\n  }\r\n\r\n  private T deserialize(final String json) {\r\n    try {\r\n      if (StringUtils.isBlank(json)) {\r\n        return null;\r\n      }\r\n\r\n      return mapper.readValue(json, type);\r\n    } catch (JsonProcessingException exception) {\r\n      log.error(\"Could not deserialize cached json {}\", json, exception);\r\n\r\n      return null;\r\n    }\r\n  }\r\n}\r\n```\n\n### Output of `uname -a` or `ver`\n\nDarwin MacBook-Pro.local 21.6.0 Darwin Kernel Version 21.6.0: Wed Aug 10 14:25:27 PDT 2022; root:xnu-8020.141.5~2/RELEASE_X86_64 x86_64\n\n### Output of `java -version`\n\nopenjdk version \"17\" 2021-09-14 OpenJDK Runtime Environment (build 17+35-2724) OpenJDK 64-Bit Server VM (build 17+35-2724, mixed mode, sharing)\n\n### GraalVM version (if different from Java)\n\n_No response_\n\n### Quarkus version or git rev\n\n2.14.2.Final\n\n### Build tool (ie. output of `mvnw --version` or `gradlew --version`)\n\nGradle 7.4.2\n\n### Additional information\n\n_No response_",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/30182/reactions",
    "total_count": 1,
    "+1": 1,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/30182/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
