{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/29187",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/29187/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/29187/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/29187/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/29187",
  "id": 1444212335,
  "node_id": "I_kwDOCFbutM5WFO5v",
  "number": 29187,
  "title": "Multipart broken in RESTEasy Reactive when using new CSRF filter",
  "labels": [
    {
      "id": 985346620,
      "node_id": "MDU6TGFiZWw5ODUzNDY2MjA=",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/kind/bug",
      "name": "kind/bug",
      "color": "d73a4a",
      "default": false,
      "description": "Something isn't working"
    },
    {
      "id": 2552031458,
      "node_id": "MDU6TGFiZWwyNTUyMDMxNDU4",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/rest",
      "name": "area/rest",
      "color": "0366d6",
      "default": false,
      "description": ""
    }
  ],
  "state": "closed",
  "locked": false,
  "milestone": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/milestones/214",
    "html_url": "https://github.com/quarkusio/quarkus/milestone/214",
    "labels_url": "https://api.github.com/repos/quarkusio/quarkus/milestones/214/labels",
    "id": 8581813,
    "node_id": "MI_kwDOCFbutM4AgvK1",
    "number": 214,
    "title": "2.15.0.CR1",
    "description": "",
    "creator": {
      "login": "gsmet",
      "id": 1279749,
      "node_id": "MDQ6VXNlcjEyNzk3NDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1279749?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gsmet",
      "html_url": "https://github.com/gsmet",
      "followers_url": "https://api.github.com/users/gsmet/followers",
      "following_url": "https://api.github.com/users/gsmet/following{/other_user}",
      "gists_url": "https://api.github.com/users/gsmet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gsmet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gsmet/subscriptions",
      "organizations_url": "https://api.github.com/users/gsmet/orgs",
      "repos_url": "https://api.github.com/users/gsmet/repos",
      "events_url": "https://api.github.com/users/gsmet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gsmet/received_events",
      "type": "User",
      "site_admin": false
    },
    "open_issues": 0,
    "closed_issues": 194,
    "state": "closed",
    "created_at": "2022-10-26T07:03:06Z",
    "updated_at": "2023-05-15T13:57:18Z",
    "due_on": null,
    "closed_at": "2022-11-30T12:45:37Z"
  },
  "comments": 5,
  "created_at": "2022-11-10T16:32:32Z",
  "updated_at": "2022-11-24T05:44:46Z",
  "closed_at": "2022-11-24T05:44:42Z",
  "active_lock_reason": null,
  "body": "### Describe the bug\r\n\r\nWhen using the new CSRF security filter, multipart support is broken in RESTEasy Reactive, leading to only the form elements that have no `filename` to be picked up. This is because the CSRF pre-matching filter suspends the request and waits for Vert.x to read the form body:\r\n\r\n```java\r\n    private static Uni<MultiMap> getFormUrlEncodedData(HttpServerRequest request) {\r\n        request.setExpectMultipart(true);\r\n        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super MultiMap>>() {\r\n            @Override\r\n            public void accept(UniEmitter<? super MultiMap> t) {\r\n                request.endHandler(new Handler<Void>() {\r\n                    @Override\r\n                    public void handle(Void event) {\r\n                        t.complete(request.formAttributes());\r\n                    }\r\n                });\r\n                request.resume();\r\n            }\r\n        });\r\n    }\r\n```\r\n\r\nWhile RESTEasy Reactive usually handles the form body parsing itself, so it has not set up Vert.x with a `BodyHandler` that would do things properly. The result is that Vert.x only populates the `formAttributes()` with the attributes it gets from Netty's `HttpPostRequestDecoder`, which don't include the attributes with a `filename`. Those would only get handled by `BodyHandler`.\r\n\r\nThen, when RESTEasy Reactive's `FormBodyHandler` gets called after the CSRF filter, before it handles the custom parsing, it checks if Vert.x already read the form, and yes it did (partially):\r\n\r\n```java\r\n        FormData existingParsedForm = requestContext.serverRequest().getExistingParsedForm();\r\n        if (existingParsedForm != null) {\r\n            requestContext.setFormData(existingParsedForm);\r\n            return;\r\n        }\r\n```\r\n\r\nBut this will only get half the form attributes. So when using the CSRF filter as it currently stands, all multipart form elements with a `filename` will be omitted, and also the custom RESTEasy Reactive form parsers are bypassed entirely, which was added because of https://github.com/quarkusio/quarkus/pull/17687 and perhaps that's more of an issue.\r\n\r\nI'm not sure if we should fix the side-effect and make sure that Vert.x populates the `fileUploads()` properly for the CSRF filter, or to find a way to make the filter run the `FormBodyHandler` before it runs. Given that it's a pre-matching filter, this appears very intrusive.\r\n\r\nPerhaps we've looked at this the wrong way, and it can't be implemented by a filter at all. Perhaps this CSRF checking should be a RR Handler that sits after the `FormBodyHandler` and before we invoke the endpoint.\r\n\r\nThis would actually allow me to solve another issue that I have in UX of this new CSRF module, because I've noticed that because we can only enable CSRF for the entire application, it means turning it on secures the HTML POST endpoints (fine) but also any REST API POST endpoints that are not meant to be called by HTML. Now, perhaps this is actually fine, because any REST API POST endpoints we define would be reacheable by HTML anyway, given that they have the same origin, and so would be vulnerable, so we should secure them anyway, or offer them via another origin. I'm not too sure about this.\r\n\r\n/CC @ser\r\n\r\n### How to Reproduce?\r\n\r\nTest:\r\n\r\n```java\r\n    @Test\r\n    public void testPost() {\r\n        RenardeCookieFilter cookieFilter = new RenardeCookieFilter();\r\n        String csrfToken = given()\r\n                .filter(cookieFilter)\r\n                .when().get(\"/Application/csrfToken\")\r\n                .then()\r\n                .statusCode(200)\r\n                .extract().asString();\r\n   \r\n        given()\r\n                .filter(cookieFilter)\r\n                .when()\r\n                .multiPart(\"csrf-token\", csrfToken)\r\n                .multiPart(\"param\", \"myParam\")\r\n                .multiPart(\"file\", \"file.txt\", \"file contents\".getBytes(), MediaType.TEXT_PLAIN)\r\n                .multiPart(\"fileUpload\", \"fileUpload.txt\", \"upload file contents\".getBytes(), MediaType.TEXT_PLAIN)\r\n                .log().all()\r\n                .post(\"/Application/form\")\r\n                .then()\r\n                .statusCode(200)\r\n                .body(is(\"param: myParam, file: file contents, fileUpload: fileUpload.txt\"));\r\n    }\r\n```\r\n\r\nEndpoint:\r\n\r\n```java\r\n@Path(\"Application\")\r\npublic class Application {\r\n\r\n    @Inject\r\n    CsrfTokenParameterProvider csrfToken;\r\n\r\n@GET\r\n@Path(\"csrfToken\")\r\n    public String csrfToken() {\r\n        return csrfToken.getToken();\r\n    }\r\n\r\n    public static class DamnMultiPart {\r\n        @RestForm\r\n        File file;\r\n        @RestForm\r\n        public FileUpload fileUpload;\r\n    }\r\n\r\n    @Consumes(MediaType.MULTIPART_FORM_DATA)\r\n@Path(\"form\")\r\n    @POST\r\n    public String form(@RestForm String param,\r\n            @MultipartForm DamnMultiPart damnit) throws IOException {\r\n        return \"param: \" + param + \", file: \" + Files.readString(damnit.file.toPath()) + \", fileUpload: \"\r\n                + damnit.fileUpload.fileName();\r\n    }\r\n}\r\n```",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/29187/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/29187/timeline",
  "performed_via_github_app": null,
  "state_reason": "completed"
}
