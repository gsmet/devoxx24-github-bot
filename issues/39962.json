{
  "url": "https://api.github.com/repos/quarkusio/quarkus/issues/39962",
  "repository_url": "https://api.github.com/repos/quarkusio/quarkus",
  "labels_url": "https://api.github.com/repos/quarkusio/quarkus/issues/39962/labels{/name}",
  "comments_url": "https://api.github.com/repos/quarkusio/quarkus/issues/39962/comments",
  "events_url": "https://api.github.com/repos/quarkusio/quarkus/issues/39962/events",
  "html_url": "https://github.com/quarkusio/quarkus/issues/39962",
  "id": 2233236903,
  "node_id": "I_kwDOCFbutM6FHH2n",
  "number": 39962,
  "title": "WebAuthn usage with JWT instead of cookies",
  "labels": [
    {
      "id": 985346622,
      "node_id": "MDU6TGFiZWw5ODUzNDY2MjI=",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/kind/enhancement",
      "name": "kind/enhancement",
      "color": "a2eeef",
      "default": false,
      "description": "New feature or request"
    },
    {
      "id": 1282139374,
      "node_id": "MDU6TGFiZWwxMjgyMTM5Mzc0",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/security",
      "name": "area/security",
      "color": "0366d6",
      "default": false,
      "description": ""
    },
    {
      "id": 6477362026,
      "node_id": "LA_kwDOCFbutM8AAAABghSzag",
      "url": "https://api.github.com/repos/quarkusio/quarkus/labels/area/webauthn",
      "name": "area/webauthn",
      "color": "0366d6",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "milestone": null,
  "comments": 9,
  "created_at": "2024-04-09T11:34:04Z",
  "updated_at": "2024-04-17T08:56:27Z",
  "closed_at": null,
  "active_lock_reason": null,
  "body": "### Description\r\n\r\nLooking how we can use JWT instead of cookies for WebAuthn support.\r\n\r\n\r\n### Implementation ideas\r\n\r\nHere is a draft implementation using JWT to begin the conversation:\r\n\r\n\r\n```java\r\n@Path(\"/webauthn\")\r\npublic class WebAuthnResource {\r\n\r\n    private static final Logger LOG = Logger.getLogger(WebAuthnResource.class);\r\n\r\n    @Inject\r\n    SecurityIdentity securityIdentity;\r\n\r\n    @Inject\r\n    WebAuthnSecurity webAuthnSecurity;\r\n\r\n    @Inject\r\n    WebAuthnRunTimeConfig config;\r\n\r\n    @Inject\r\n    WebAuthnCredentialRepository webAuthnCredentialRepository;\r\n\r\n    @Inject\r\n    WebAuthnCertificateRepository webAuthnCertificateRepository;\r\n\r\n    @Inject\r\n    UserRepository userRepository;\r\n\r\n    @Inject\r\n    JWTParser jwtParser;\r\n\r\n\r\n    // LargeBlob Not Well supported:\r\n    //https://www.webkit.org/blog/14205/news-from-wwdc23-webkit-features-in-safari-17-beta/#browser-changes -- SEE Authentication section.\r\n    // Support for largeBlob extension\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/WebAuthn_extensions#largeblob\r\n\r\n    //https://www.security-embedded.com/blog/2021/5/2/under-the-hood-webauthn-in-safari\r\n\r\n    //DO-NOT compare raw base64 of clientDataJSON: https://chromium.googlesource.com/chromium/src/+/refs/heads/main/content/browser/webauth/client_data_json.md\r\n    // always parse it and compare specific fields/properties\r\n\r\n\r\n    @Path(\"/register\")\r\n    @POST\r\n    @Transactional\r\n    @Consumes(MediaType.APPLICATION_JSON)\r\n    @Produces(MediaType.APPLICATION_JSON)\r\n//    @RolesAllowed(\"user\")\r\n    public Uni<RestResponse<JsonObject>> addAuthenticator(JsonObject body) {\r\n        return Uni.createFrom().completionStage(\r\n                webAuthnSecurity.getWebAuthn()\r\n                        .createCredentialsOptions(body)\r\n                        .toCompletionStage() // Generates the content explaining to the client how to auth\r\n        ).map(Unchecked.function(credentialsOptions -> { // json of config for the client\r\n            // if authenticator was already registered then the found credentials is returned as part of the list;\r\n            // So registration means: A Request to register, and the callback is the actual registration\r\n            // The Request to register provides information about existing credentials associated with the user\r\n\r\n            String jwtSubject = \"SOME_SUBJECT_HERE\"; // @TODO this is replaced with value from SecurityIdentity principal\r\n\r\n            var jwt = Jwt.claims()\r\n                    .claim(\"someCustomData\", new JsonObject().put(\"someField\", \"happy\"))\r\n                    .claim(\"action\", \"register\")\r\n                    .claim(\"authenticatorName\", \"someName\")\r\n                    .issuer(\"https://localhost:8080/issuer\")\r\n                    .subject(jwtSubject)\r\n                    .expiresIn(Duration.ofMinutes(1)).issuedAt(Instant.now()).sign(); // 1min + 60s of clock skew by jwt lib\r\n\r\n            try {\r\n                jwtParser.parse(jwt); //DoubleCheck // validates the JWT/challenge\r\n            } catch (ParseException e) {\r\n                throw new IllegalStateException(\"Generated Challenge/JWT is invalid\", e);\r\n            }\r\n\r\n            var base64urlJwt = Base64.getUrlEncoder().encodeToString(jwt.getBytes(StandardCharsets.UTF_8));\r\n\r\n            credentialsOptions.put(\"challenge\", base64urlJwt);\r\n\r\n            return credentialsOptions;\r\n\r\n            //@TODO add LOGIC for updating of authenticators? Or should be a delete?\r\n\r\n        })).map(RestResponse::ok); // Response tells the browser what sort of conditions to give to the user for the use of the authenticator.\r\n    }\r\n\r\n\r\n    @Path(\"/login\")\r\n    @POST\r\n    @Transactional\r\n    @Consumes(MediaType.APPLICATION_JSON)\r\n    @Produces(MediaType.APPLICATION_JSON)\r\n    //    @RolesAllowed(\"user\")\r\n    public Uni<RestResponse<String>> login(JsonObject body) {\r\n//        var username = body.getString(\"name\");// Use if you need username defined by authenticator\r\n        String username = \"SOME_SUBJECT_HERE\"; // @TODO this is replaced with value from SecurityIdentity principal // used when a bearer token was already provided\r\n\r\n        return Uni.createFrom().completionStage(\r\n                        webAuthnSecurity.getWebAuthn().getCredentialsOptions(username).toCompletionStage() // default challenge from vertx WebAuthnImpl = .put(\"challenge\", randomBase64URLBuffer(options.getChallengeLength()));\r\n                ).onFailure().transform(t -> new AuthenticationFailedException(t.getMessage(), t))\r\n                .map(Unchecked.function(credentialOptions -> {\r\n\r\n                            String jwtSubject = \"SOME_SUBJECT_HERE\"; // @TODO this is replaced with value from SecurityIdentity principal\r\n\r\n                            var jwt = Jwt.claims()\r\n                                    .claim(\"someCustomData\", new JsonObject().put(\"someField\", \"happy days\"))\r\n                                    .claim(\"action\", \"login\")\r\n                                    .claim(\"authenticatorName\", \"someName\")\r\n                                    .issuer(\"https://localhost:8080/issuer\")\r\n                                    .subject(jwtSubject)\r\n                                    .expiresIn(Duration.ofMinutes(1)).issuedAt(Instant.now()).sign(); // 1min + 60s of clock skew by jwt lib\r\n\r\n                            try {\r\n                                jwtParser.parse(jwt); //DoubleCheck // validates the JWT/challenge\r\n                            } catch (ParseException e) {\r\n                                throw new IllegalStateException(\"Generated Challenge/JWT is invalid\", e);\r\n                            }\r\n\r\n                            var base64urlJwt = Base64.getUrlEncoder().encodeToString(jwt.getBytes(StandardCharsets.UTF_8));\r\n\r\n                            credentialOptions.put(\"challenge\", base64urlJwt);\r\n\r\n                            return RestResponse.ok(credentialOptions.encode());\r\n                        })\r\n\r\n                ).onFailure(AuthenticationFailedException.class).recoverWithItem(t ->\r\n                        RestResponse.status(RestResponse.Status.BAD_REQUEST,\r\n                                JsonObject.of(\"error\", t.getMessage()).encode()\r\n                        )\r\n                );\r\n    }\r\n\r\n\r\n    @Path(\"/callback\")\r\n    @POST\r\n    @Transactional\r\n    @Consumes(MediaType.APPLICATION_JSON)\r\n    @Produces(MediaType.APPLICATION_JSON)\r\n//    @RolesAllowed(\"user\")\r\n    public Uni<RestResponse<Void>> callback(JsonObject webauthnResp) { // The response from the authenticator / signed data\r\n\r\n        var clientDataJSON = webauthnResp.getJsonObject(\"response\").getString(\"clientDataJSON\");\r\n        var decodedClientDataJSON = new String(Base64.getUrlDecoder().decode(clientDataJSON));\r\n        var parsedClientDataJSON = new JsonObject(decodedClientDataJSON);\r\n        var clientDataJSONChallenge = parsedClientDataJSON.getString(\"challenge\");\r\n        var decodedChallenge = new String(Base64.getUrlDecoder().decode(clientDataJSONChallenge));\r\n\r\n        String actionType;\r\n        String userName;\r\n        try {\r\n            var jwt = jwtParser.parse(decodedChallenge); // Validates the JWT/the Challenge to ensure JWT is valid per server\r\n            actionType = jwt.getClaim(\"action\");\r\n            userName = jwt.getSubject(); // @TODO This could also be to compare against the currently logged-in user to ensure they match using SecurityIdentity\r\n        } catch (ParseException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n\r\n        //@NOTE LOGIN usage could be done here to authenticate / set securityIdentity based on parsed JWT from the challenge\r\n\r\n        //@TODO figure out better usage and should it match with JWT configs?\r\n        var origin = config.origin.orElse(null);\r\n        String domain = null;\r\n        if (origin != null) {\r\n            Origin o = Origin.parse(origin);\r\n            domain = o.host();\r\n        }\r\n\r\n        WebAuthnCredentials credentials = new WebAuthnCredentials()\r\n                .setOrigin(origin)\r\n                .setDomain(domain)\r\n                .setChallenge(clientDataJSONChallenge)\r\n                .setUsername(userName)\r\n                .setWebauthn(webauthnResp); // The response from the authenticator / the signed challenge\r\n\r\n\r\n        if (Objects.equals(actionType, \"register\")) {\r\n            return Uni.createFrom().completionStage(\r\n                    webAuthnSecurity.getWebAuthn().authenticate(credentials).toCompletionStage() // Ensures that the data signed by authenticator is accurate based on public key provided by authenticator\r\n            ).map(Unchecked.function(u -> {\r\n                // u = the user as defined by the authenticator / it is the authenticator's info/public key etc\r\n                var authenticator = new Authenticator(u.principal());\r\n                //@TODO add error handling is auth did not succeed.\r\n\r\n                var user = userRepository.findByUsername(userName); // use username from JWT\r\n                if (user.isEmpty()) {\r\n                    throw new IllegalArgumentException(\"User/subject from jwt cannot be found\");\r\n                }\r\n\r\n                //DB Storage:\r\n                WebAuthnCredential credential = new WebAuthnCredential(authenticator, user.get());\r\n\r\n                credential.counter = 0L;\r\n                //https://www.imperialviolet.org/2023/08/05/signature-counters.html\r\n                //https://github.com/w3c/webauthn/issues/1734\r\n                //It also not appear in Vertx's WebAuthnImpl.java that the counter value is NOT changed per login.\r\n                //https://github.com/w3c/webauthn/issues/1734\r\n\r\n                webAuthnCredentialRepository.persist(credential);\r\n                webAuthnCertificateRepository.persist(credential.x5c); //@TODO review usage as x5c does not appear to be correct\r\n\r\n                return RestResponse.ok();\r\n            }));\r\n\r\n        } else if (Objects.equals(actionType, \"login\")) {\r\n            return Uni.createFrom().completionStage(\r\n                    webAuthnSecurity.getWebAuthn().authenticate(credentials).toCompletionStage()\r\n            ).map(Unchecked.function(u -> { // u = the user as defined by the authenticator / it is the authenticator's info/public key etc\r\n                var authenticator = new Authenticator(u.principal());\r\n                var credential = webAuthnCredentialRepository.findByCredID(authenticator.getCredID());\r\n\r\n                //@TODO Where you would increment the counter?\r\n\r\n                //@TODO add error handling is auth did not succeed.\r\n\r\n                return RestResponse.ok();\r\n            }));\r\n\r\n        } else {\r\n            throw new IllegalArgumentException(\"Challenge JWT has unsupported action claim\");\r\n        }\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n\r\nUsage of JWT was do with logic of: The challenge is the Signed JWT.  The authenticator would sign the challenge, and if correctly signed, then we would unpack the challenge and validate the short-lived jwt which contains the \"action\" logic to be performed.\r\n\r\nRepay attack mitigation would be typically managed through the short-lived jwt and idempotency\r\n",
  "reactions": {
    "url": "https://api.github.com/repos/quarkusio/quarkus/issues/39962/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/quarkusio/quarkus/issues/39962/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
